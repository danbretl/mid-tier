from django.core.management.base import BaseCommand
from importer.api.eventful.paginator import EventfulPaginator
from optparse import make_option
from events.models import Event
from core.utils import dict_from_values
from importer.api.eventful import conf 

class Command(BaseCommand):
    help = 'Loads scraped object generated by eventful'
    option_list = BaseCommand.option_list + (
        # paginator args
        make_option('--interactive',
                    action='store_true',
                    dest='interactive',
                    default=False,
                    help='Import events in interactive mode'),
        make_option('--start-page',
                    action='store',
                    dest='start_page',
                    type='int',
                    help='Page to start on'),
        make_option('--total-pages',
                    action='store',
                    dest='total_pages',
                    type='int',
                    help='Total pages of events to fetch'),

        # consumer kwargs
        make_option('--mock-api',
                    action='store_true',
                    dest='mock_api',
                    default=False,
                    help='Use mock API class'),
        make_option('--trust',
                    action='store_true',
                    dest='trust',
                    default=False,
                    help='''If set, import as many events as possible until api client_call_limit is reached,
                    without asking for confirmation. Else ask for confirmation
                    if projected amount of API calls exceeds half of client_call_limit, and
                    do not exceed half of that client_call_limit in calls'''),


        # client kwargs
        make_option('--make-dumps',
                    action='store_true',
                    dest='make_dumps',
                    default=False,
                    help='Use mock API class'),

        # query kwargs
        make_option('--page-size',
                    action='store',
                    dest='page_size',
                    type='int',
                    help='Amount of events per page to fetch'),

        # FIXME implement
        make_option('--dry-run',
                    action='store_true',
                    dest='dry_run',
                    default=True,
                    help='Save to db or not')
    )

    def handle(self, **options):
        options = dict_from_values(options)
        paginator_kwargs = dict((key, options[key]) for key in filter(options.has_key, ('total_pages', 'start_page', 'interactive')))
        consumer_kwargs = dict((key, options[key]) for key in filter(options.has_key, ('mock_api', 'trust')))
        client_kwargs = dict((key, options[key]) for key in filter(options.has_key, ('make_dumps',)))

        # mux up settings with overrides
        query_kwargs = dict((key, options[key]) for key in filter(options.has_key, ('page_size',)))
        mux_query_kwargs = dict(conf.IMPORT_PARAMETERS, **query_kwargs)

        # do work
#        try:
        paginator = EventfulPaginator(client_kwargs=client_kwargs,
                query_kwargs=mux_query_kwargs, consumer_kwargs=consumer_kwargs, **paginator_kwargs)
        results = paginator.import_events()

        # FIXME should prolly happen automagically elsewhere
        for e in Event.objects.filter(id__in=[event_id for created, event_id in results]):
            e.save()

        #        except Exception, e:
        #            raise CommandError(e)
        #        else:
        created_events_count = reduce(lambda count, result: count + int(result[0]), results, 0)
        self.stdout.write('Successfully imported eventful API results: %i total | %i created.\n' % (
            len(results), created_events_count)
        )
